{"version":3,"sources":["showTime.js","Todolist/Todoinput.js","Todolist/Todoing.js","Todolist/Todolist.js","index.js"],"names":["Component","Todoinput","handleInput","e","keyCode","props","add","target","value","handleChange","setState","name","parseInt","bind","state","a","b","c","console","log","this","focus","ref","inp","onChange","onKeyDown","type","onClick","Todoing","todo","map","item","idx","key","del","defaultProps","Todolist","addItem","data","delItem","splice","obj","o","Object","assign","keys","forEach","ReactDOM","render","document","getElementById","className"],"mappings":"yNAGuBA,Y,6CCDFC,E,YACjB,aAAc,IAAD,8BACT,+CAQJC,YAAY,SAACC,GAEM,KAAZA,EAAEC,SAED,EAAKC,MAAMC,IAAIH,EAAEI,OAAOC,QAbnB,EAgBbC,aAAa,SAACN,GACV,EAAKO,SAAL,eACKP,EAAEI,OAAOI,KAAMC,SAA0B,KAAjBT,EAAEI,OAAOC,MAAW,EAAEL,EAAEI,OAAOC,UAhB5D,EAAKN,YAAY,EAAKA,YAAYW,KAAjB,gBACjB,EAAKC,MAAM,CACPC,EAAE,GACFC,EAAE,GACFC,EAAE,IANG,E,iFAuBTC,QAAQC,IAAIC,MACZA,KAAKL,EAAEM,U,+BAID,IAAD,OAGL,OACI,6BACI,2BAAOC,IAAK,SAACC,GAAO,EAAKR,EAAEQ,GAAMZ,KAAK,IAAIa,SAAUJ,KAAKX,aAAcD,MAAOY,KAAKN,MAAMC,EAAGU,UAAWL,KAAKlB,YAAawB,KAAK,SADlI,IAGI,2BAAOf,KAAK,IAAIa,SAAUJ,KAAKX,aAAcD,MAAOY,KAAKN,MAAME,EAAGS,UAAWL,KAAKlB,YAAawB,KAAK,SAHxG,IAKI,2BAAOf,KAAK,IAAIa,SAAUJ,KAAKX,aAAcD,MAAOY,KAAKN,MAAMG,EAAGQ,UAAWL,KAAKlB,YAAawB,KAAK,SALxG,IAQI,2BAAIN,KAAKN,MAAMC,EAAEK,KAAKN,MAAME,EAAEI,KAAKN,MAAMG,GACzC,2BAAOK,IAAK,SAACC,GAAO,EAAKA,IAAIA,GAAMG,KAAK,SACxC,4BAAQC,QAAS,WAAKT,QAAQC,IAAI,EAAKI,IAAIf,SAA3C,qB,GA3CuBR,aCClB4B,E,iLAUP,IAAD,OACAC,EAAMT,KAAKf,MAAXwB,KACL,OACI,4BAEIA,EAAKC,KAAI,SAACC,EAAKC,GACX,OAAO,wBAAIC,IAAKD,GAAMD,EAAf,MACP,4BAAQJ,QAAS,SAACxB,GAAD,OAAK,EAAKE,MAAM6B,IAAIF,EAAI7B,KAAzC,yB,GAjBiBH,aAgCrC4B,EAAQO,aAAa,CACnBN,KAAK,CAAC,EAAE,EAAE,EAAE,EAAE,I,IC7BKO,E,YACjB,aAAc,IAAD,uBACT,+CA6CJC,QAAQ,SAACC,GAKL,EAAK5B,SAAS,CACVmB,KAAK,GAAD,mBAAK,EAAKf,MAAMe,MAAhB,CAAqBS,OApDpB,EAuDbC,QAAQ,SAACP,EAAI7B,GAETe,QAAQC,IAAIhB,GACZe,QAAQC,IAAIa,GACZ,IAAIH,EAAK,YAAI,EAAKf,MAAMe,MACxBA,EAAKW,OAAOR,EAAI,GAUhB,EAAKtB,UAAS,SAACI,EAAMT,GAEjB,OADAa,QAAQC,IAAIL,EAAMe,MACX,CACHA,KAAKA,OAvEb,EAAKf,MAAM,CACPe,KAAK,CAAC,EAAE,EAAE,IAEd,IAAIY,EAAI,CAAC1B,EAAE,IAAIC,EAAE,CAAC,EAAE,EAAE,IA4BlB0B,EAAEC,OAAOC,OAAO,GAAGH,EADd,CAACxB,EAAE,MAhCH,OAkCTyB,EAAE1B,EAAE,GAAG,IACPE,QAAQC,IAAIsB,GACZvB,QAAQC,IAAIuB,IAAID,GAChBvB,QAAQC,IAAIwB,OAAOE,KAAKJ,IAExBE,OAAOE,KAAKJ,GAAKK,SAAQ,SAACf,GACtBb,QAAQC,IAAIY,GACZb,QAAQC,IAAIsB,EAAIV,OAzCX,E,sEAiFT,OACI,6BACI,kBAAC,EAAD,CAAWzB,IAAKc,KAAKiB,UACrB,kBAAC,EAAD,CAASH,IAAKd,KAAKmB,QAASV,KAAMT,KAAKN,MAAMe,Y,GArFvB7B,aCItC+C,IAASC,OAAO,kBAAC,EAAD,MAAYC,SAASC,eAAe,SA8H5CD,SAASC,eAAe,QAI5BC,UAAU,W","file":"static/js/main.c1b326bb.chunk.js","sourcesContent":["import React,{Fragment,Component} from 'react';\r\n\r\n//类定义组件\r\nclass ShowTime extends Component{\r\n    //状态\r\n    constructor(props){\r\n        super(props);\r\n        this.state={\r\n            time:new Date().toLocaleString(),\r\n            a:100,\r\n            b:200\r\n        }\r\n        console.log('constructor');\r\n        setTimeout(()=>{\r\n            this.setState({\r\n                time:new Date().toLocaleString()\r\n            })\r\n        },1000)\r\n    }\r\n    shouldComponentUpdate(){\r\n        if(this.state.a>10){\r\n            return true;\r\n        }else{\r\n            return false;\r\n        }\r\n    }\r\n    componentDidUpdate(preProps,preState,data){\r\n        console.log('didupdate');\r\n        console.log(preState)\r\n        console.log(this.state.time);\r\n    }\r\n    getSnapshotBeforeUpdate(){\r\n        console.log('getSnaphot');\r\n        return {name:this.state.a};\r\n    }\r\n    componentDidMount(){\r\n        console.log('didmount');\r\n    }\r\n    render(){\r\n        // console.log('render');\r\n        var {name,age}=this.props;//this.props.name=name\r\n        return (<Fragment>\r\n            {/**条件渲染   三种形式，if看情况才能用*/}\r\n            {name.length>5?<div>姓名：{name}</div>:''}\r\n            {name.length>5&&<div>姓名：{name}</div>}\r\n            \r\n            <div>{this.state.time}</div>\r\n            {/*循环渲染 */}\r\n            <div>\r\n               {\r\n                   age.map((item,index)=>{\r\n                       if(index%2===0){\r\n                        return <p key={index}>{item}</p>\r\n                       }\r\n                   })\r\n               }\r\n            </div>\r\n        </Fragment>\r\n        )\r\n    }\r\n}\r\n//默认导出：只能导出一次，被引入时可以重命名\r\n// export default ShowTime;\r\n\r\n//命名导出：可以导出多个，被引入时、可以重命名\r\nexport {ShowTime};\r\nexport const num=100;\r\nexport const num1=200;","import React, { Component } from 'react'\r\n//可以实时获取表单元素的值（实现表单验证）写法相对麻烦\r\nexport default class Todoinput extends Component {\r\n    constructor(){\r\n        super();\r\n        this.handleInput=this.handleInput.bind(this);\r\n        this.state={\r\n            a:'',\r\n            b:'',\r\n            c:''\r\n        }\r\n    }\r\n    handleInput=(e) =>{\r\n        //绑定this，事件处理函数写成箭头函数，或者用bind\r\n        if(e.keyCode===13){\r\n            // console.log(e.target.value);//发生事件的元素\r\n            this.props.add(e.target.value);\r\n        }\r\n    }\r\n    handleChange=(e)=>{\r\n        this.setState({\r\n            [e.target.name]:parseInt(e.target.value===''?0:e.target.value)//对应属性及值\r\n        })\r\n    }\r\n    //Redener执行结束后，自动调用componentDidMount函数（生命周期）\r\n    componentDidMount(){\r\n        console.log(this);\r\n        this.a.focus();\r\n        // this.refs.a.focus();//此时input应该为ref='a'\r\n        //获取节点只能用ref，所以第一个input中引入ref\r\n    }\r\n    render() {\r\n        //写上value值后。框内无法在写入\r\n        //受控组件：value值被react控制的表单元素\r\n        return (\r\n            <div>\r\n                <input ref={(inp)=>{this.a=inp}} name=\"a\" onChange={this.handleChange} value={this.state.a} onKeyDown={this.handleInput} type=\"text\"></input>\r\n                +\r\n                <input name=\"b\" onChange={this.handleChange} value={this.state.b} onKeyDown={this.handleInput} type=\"text\"></input>\r\n                +\r\n                <input name=\"c\" onChange={this.handleChange} value={this.state.c} onKeyDown={this.handleInput} type=\"text\"></input>\r\n                =\r\n                {/**非受控组件：一次性获取或处理表单元素的值 */}\r\n                <p>{this.state.a+this.state.b+this.state.c}</p>\r\n                <input ref={(inp)=>{this.inp=inp}} type='text'></input>\r\n                <button onClick={()=>{console.log(this.inp.value)}}>提交</button>\r\n            </div>\r\n        )\r\n    }\r\n}\r\n\r\n\r\n//类 事件 处理函数 value\r\n//受控组件：\r\n//非受控组件：只要拿到引用就可以\r\n//1、给input标签输入\r\n","import React, { Component } from 'react'\r\nimport PropTypes from 'prop-types';\r\n\r\nexport default class Todoing extends Component {\r\n\r\n    // delItem(idx,e){\r\n    //     //深拷贝\\浅拷贝\r\n    //     var obj={a:100};\r\n    //     var o=obj;\r\n    //     o.a=200;\r\n    //     console.log(obj);\r\n    // }\r\n   \r\n    render() {\r\n        var {todo}=this.props;\r\n        return (\r\n            <ul>\r\n              {\r\n                todo.map((item,idx)=>{\r\n                    return <li key={idx}>{item}---\r\n                    <button onClick={(e)=>this.props.del(idx,e)}>删除</button>\r\n                    </li>\r\n                })  //其中this.props.del不能直接加小括号，因为这表示调用\r\n              }              \r\n            </ul>\r\n        )\r\n    }\r\n}\r\n\r\n//类型检查\r\nTodoing.propTypes={\r\n  todo:PropTypes.array,//因为todo为数组，所以写string会报错\r\n  del:PropTypes.func\r\n}\r\n\r\nTodoing.defaultProps={\r\n  todo:[1,2,3,4,4]\r\n}\r\n\r\n","import React, { Component } from 'react'\r\nimport Todoinput from './Todoinput'\r\nimport Todoing from './Todoing'\r\n\r\n\r\n//父子组件之间传\r\n//组件传参，事件绑定，组件交互\r\nexport default class Todolist extends Component {\r\n    constructor(){\r\n        super();\r\n        this.state={\r\n            todo:[1,2,3]\r\n        }\r\n        var obj={a:100,b:[1,2,3]};\r\n        //方式一：\r\n        // var o=obj;\r\n        // o.a=200;\r\n        // o.b[0]=200;[200,2,3]\r\n        // console.log(obj);//a为200\r\n\r\n        //方式二：\r\n        // var o={...obj};\r\n        // o.a=200;\r\n        // o.b[0]=200;//[200,2,3]浅拷贝\r\n        // console.log(obj);//a为100\r\n\r\n        //方式三：\r\n        // var o=JSON.parse(JSON.stringify(obj));\r\n        // o.b[0]=200;\r\n        // console.log(obj);//[1,2,3]深拷贝\r\n\r\n\r\n        //方式四：\r\n        // var obj1={c:300};\r\n        // var o=Object.assign(obj,obj1);\r\n        // console.log(obj);\r\n        // console.log(o===obj);//true\r\n\r\n        //方式五：\r\n        //obj和o是不一样的，但还是浅拷贝，例如b中的值会变化\r\n        var obj1={c:300};\r\n        var o=Object.assign({},obj,obj1);\r\n        o.b[0]=200;\r\n        console.log(obj);\r\n        console.log(o===obj);//false\r\n        console.log(Object.keys(obj));\r\n        //Object.keys记住\r\n        Object.keys(obj).forEach((item)=>{\r\n            console.log(item);\r\n            console.log(obj[item]);\r\n        })\r\n\r\n    }\r\n    \r\n    addItem=(data)=>{\r\n        // console.log(data);\r\n        // this.state.todo.push(data);//不要对状态进行任何的处理\r\n        //想要改变状态可以用setState\r\n        // console.log(this.state.todo);\r\n        this.setState({\r\n            todo:[...this.state.todo,data]\r\n        })\r\n    }\r\n    delItem=(idx,e)=>{\r\n        //1、不能直接改变或处理state，通过setState改变\r\n        console.log(e);\r\n        console.log(idx);\r\n        let todo=[...this.state.todo];\r\n        todo.splice(idx,1);\r\n        //2、setState是异步执行\r\n        //方法一：\r\n        // this.setState({\r\n        //     todo:todo\r\n        // },()=>{\r\n        //     console.log(this.state.todo);//值改变\r\n        // })\r\n        // console.log(this.state.todo);//还是原来的值，因为setState异步\r\n        \r\n        this.setState((state,props)=>{\r\n            console.log(state.todo);//上一个值\r\n            return {\r\n                todo:todo\r\n            }\r\n        })\r\n        //在setState里胡浩去state可能会出错，不是你想要的值\r\n        //可以像上面一样\r\n    }\r\n    render() {\r\n        //add是属性\r\n        return (\r\n            <div>\r\n                <Todoinput add={this.addItem}/>\r\n                <Todoing del={this.delItem} todo={this.state.todo}/>\r\n            </div>\r\n        )\r\n    }\r\n}\r\n","import React,{Fragment,Component} from 'react';\nimport {ShowTime} from './showTime'\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport Todolist from './Todolist/Todolist';\n\n\n//map是循环\n//属性是props，子用父中的方法是this.props.属性名\n\n\nReactDOM.render(<Todolist/>,document.getElementById('root'));\n\n//函数声明组件\n//props是一个属性对象（只读） return必须在一个闭合的标签里面\n//React.Fragment解构赋值，在上面引入Fragment\n// function ShowTime(props){\n//     console.log(props);\n//     return (<Fragment>\n//             <div>{props.age}</div>\n//             <div>{props.name}</div>\n//             <div>{new Date().toLocaleString()}</div>\n//         </Fragment>\n//     )\n// }\n\n\n//组件的交互\n//父组件---->子组件：调用子组件时，添加属性，子组件通过props拿到传递的数据\n//子组件---->父组件：\n\n// var num=[1,2,3,4,5];\n\n// ReactDOM.render(<ShowTime age={num} name=\"zhangsan\"/>,document.getElementById(\"root\"));\n\n\n\n\n\n\n\n\n\n//显示当前系统时间\n//其中p不更新，div更新，不变所以不更新\n// function showTime(){\n//     var ele=<div>\n//         <p>当前时间是：</p>\n//         <div>{new Date().toLocaleString()}</div>\n//     </div>;\n//     ReactDOM.render(\n//         ele,\n//         document.querySelector(\"#root\")\n//     );\n// }\n// showTime();\n// setInterval(showTime,1000);//不能为showTime()\n\n\n\n// var str='react';\n// var ele=<h1>hello {str}</h1>\n// var ele=<h1>hello react</h1>;\n// var ele=<h1 class=\"tit\">hello {str}</h1>;\nvar obj={\n    type:'div',\n    props:{\n        id:'tit',\n        class:'tit',\n        children:['hello','react',\n        {\n            type:'h1',\n            props:{\n                id:'titt',\n                class:'tittt',\n                children:['yyyy']\n            }\n        }\n\n    ]\n    }\n    \n}\n\n//渲染\nfunction render(obj,container){\n\n    //解构赋值\n    var {type,props}=obj;\n\n    //文档碎片\n    var fragment=document.createDocumentFragment();\n    \n    var ele=document.createElement(type);\n    for(var item in props){\n        if(item=='class'){\n            ele.className=props[item];\n        }else if(item='children'){\n           for(var i=0;i<props.children.length;i++){\n                // ele.innerHTML+=props.children[i];\n                if(typeof props.children[i]==='object'){\n                    render(props.children[i],ele)\n                }else{\n                    var txt=document.createTextNode(props.children[i]);\n                    ele.appendChild(txt);\n                }\n           }\n        }else{\n            ele[item]=props[item];\n        }\n    }\n    fragment.appendChild(ele)\n    container.appendChild(fragment);\n}\n// render(obj,document.getElementById('root'));\n//页面渲染过程\n//请求HTML页面，浏览器HTML解析器解析HTML文件、生成DOM树\n//link引入css文件、css解析器解析css，生成css对象模型，CSSOM和\n//DOM tree结合生成一个render tree,最后浏览器绘制页面\n//页面回流（重排reflow）：DOM结构变化、内容变化、大小、位置的变化、显示的变化\n//页面重绘（repaint）：颜色的变化（背景色、字体颜色、边框颜色）\n//回流一定重绘，重绘不一定回流\n\n//1、现用变量进行DOM处理，最后一次渲染（节省时间）\n// console.time('time');\n// var div=document.getElementById('root');\n// var str='';\n// for(var i=0; i<1000;i++){\n//     str+='<p>'+i+'</p>';\n//     document.getElementById('root').innerHTML=\n//      '<p>'+i+'</p>';//浪费时间,处于回流\n// }\n// div.innerHTML=str;\n// console.timeEnd('time');\n\n//2、对于样式处理,声明一个css类\n\nvar div=document.getElementById('root');\n// div.style.width='100px';\n// div.style.height='100px';\n// div.style.background='red';\ndiv.className='active';\n\n//3、offsetLeft、offsetWidth等都会引起回流，要慎用\n// console.log(div.offsetLeft);\n// var wid=div.offsetWidth;//不要再循环中用，\n// setInterval(()=>{\n//     wid+=1;\n//     div.style.width=wid+'px';\n//     // div.style.width=div.offsetWidth+1+'px';//代码效率不高\n// },100)\n\n//4、文档碎片（内存中的一个变量）\n\n\n\n\n\n\n\n\n\n\n\n\n// var ele=React.createElement(\n//     'h1',\n//     {id:'tit',class:'title'},\n//     'hello',\n//     React.createElement('p',{id:'t',class:'titi'},'react')\n    \n    \n//     );\n// var ele=<h1>hello<p>react</p></h1>\n// console.log(ele);\n\n// ReactDOM.render(ele, document.getElementById('root'));\n\n\n\n"],"sourceRoot":""}